#!/usr/bin/env bash
# shellcheck shell=bash
set -euo pipefail
HERE="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib.sh
. "$HERE/lib.sh"

START=""
END=""
ISO_WEEK=""   # e.g. 2025-45
NO_LLM=0
NO_OPEN=0
MODEL="${LLM_MODEL_SUMMARY:-o3-mini}"

usage() {
  cat <<USAGE
Usage: weekly-review [--start YYYY-MM-DD --end YYYY-MM-DD] [--week YYYY-WW] [--no-llm] [--no-open] [--model NAME]
If no range is provided, uses the current ISO week (Mon..Sun).
Outputs: reviews/YYYY/YYYY-WW.md
USAGE
  exit 1
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --start) START="$2"; shift 2 ;;
    --end) END="$2"; shift 2 ;;
    --week) ISO_WEEK="$2"; shift 2 ;;
    --no-llm) NO_LLM=1; shift ;;
    --no-open) NO_OPEN=1; shift ;;
    --model) MODEL="$2"; shift 2 ;;
    -h|--help) usage ;;
    *) echo "Unknown arg: $1"; usage ;;
  esac
done

# Compute window
vals="$(python3 - <<'PY'
import datetime
today = datetime.date.today()
monday = today - datetime.timedelta(days=today.weekday())
sunday = monday + datetime.timedelta(days=6)
y, w, _ = today.isocalendar()
print(monday.isoformat(), sunday.isoformat(), y, f"{w:02d}")
PY
)"
read -r DFLT_START DFLT_END YEAR WEEKNUM <<< "$vals"
if [[ -n "$ISO_WEEK" ]]; then
  # Parse YYYY-WW to Monday..Sunday
  vals2="$(python3 - "$ISO_WEEK" <<'PY'
import sys, datetime
y, w = sys.argv[1].split('-')
y = int(y); w = int(w)
monday = datetime.date.fromisocalendar(y, w, 1)
sunday = monday + datetime.timedelta(days=6)
print(monday.isoformat(), sunday.isoformat(), y, f"{w:02d}")
PY
)"
  read -r START END YEAR WEEKNUM <<< "$vals2"
else
  START="${START:-$DFLT_START}"
  END="${END:-$DFLT_END}"
  # If START/END were provided, compute YEAR and WEEKNUM from START date
  if [[ -n "$START" && "$START" != "$DFLT_START" ]]; then
    vals3="$(python3 - "$START" <<'PY'
import sys, datetime
d = datetime.date.fromisoformat(sys.argv[1])
y, w, _ = d.isocalendar()
print(y, f"{w:02d}")
PY
)"
    read -r YEAR WEEKNUM <<< "$vals3"
  fi
fi

OUTDIR="$NOTES_DIR/reviews/$YEAR"
ensure_dir "$OUTDIR"
OUT="$OUTDIR/$YEAR-$WEEKNUM.md"

echo "Building weekly review for $START .. $END -> $OUT"

# Collect candidate files by date in filename (YYYY-MM-DD)
FILES=()
while IFS= read -r line; do
  [[ -n "$line" ]] && FILES+=("$line")
done < <(find "$JOURNAL_DIR" "$MEETINGS_DIR" -type f -name '*.md' 2>/dev/null \
  | grep -E '/[0-9]{4}/[0-9]{4}-[0-9]{2}/[0-9]{4}-[0-9]{2}-[0-9]{2}.*\.md$' \
  | awk -v s="$START" -v e="$END" '
      {
        # Extract YYYY-MM-DD date from filename
        match($0, /[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]/)
        d = substr($0, RSTART, RLENGTH)
        if (d >= s && d <= e) print
      }' \
  | sort)

# Helper: extract a section by H2 name
extract_section() {
  local file="$1"; local heading="$2"
  awk -v h="$(echo "$heading" | tr '[:upper:]' '[:lower:]')" '
    BEGIN{found=0}
    /^[[:space:]]*##[[:space:]]/ {
      # Heading line
      line = tolower($0)
      if (found && line ~ /^[[:space:]]*##[[:space:]]/) { exit }  # next section
      if (line ~ "^[[:space:]]*##[[:space:]]" h "[[:space:]]*$") { found=1; next }
    }
    found { print }
  ' "$file"
}

# Aggregate actions and decisions
ACTIONS_TMP="$(mktemp)"; DECISIONS_TMP="$(mktemp)"; LINKS_TMP="$(mktemp)"
: > "$ACTIONS_TMP"; : > "$DECISIONS_TMP"; : > "$LINKS_TMP"

for f in "${FILES[@]+"${FILES[@]}"}"; do
  relroot="$(dirname "$OUT")"
  rel="$(relpath "$f" "$relroot")"
  echo "- [$(basename "$(dirname "$f")")/$(basename "$f")]($rel)" >> "$LINKS_TMP"

  # Decisions
  if extract_section "$f" "Decisions" | grep -q '[^[:space:]]'; then
    echo "### $(basename "$f")" >> "$DECISIONS_TMP"
    extract_section "$f" "Decisions" >> "$DECISIONS_TMP"
    echo "" >> "$DECISIONS_TMP"
  fi

  # Actions (unchecked boxes anywhere in the file)
  if rg -n '^\s*-\s*\[ \]\s' "$f" > /dev/null 2>&1; then
    while IFS=: read -r file line text; do
      task="$(printf '%s' "$text" | sed -E 's/^\s*-\s*\[ \]\s*//')"
      link="$(relpath "$file" "$relroot")#L$line"
      printf -- "- [ ] %s  _(in [%s](%s))_\n" "$task" "$(basename "$file")" "$link" >> "$ACTIONS_TMP"
    done < <(rg -n '^\s*-\s*\[ \]\s' "$f")
  fi
done

# Optional LLM summary if available
SUMMARY=""
if [[ $NO_LLM -eq 0 && ${#FILES[@]} -gt 0 && $(command -v llm >/dev/null 2>&1; echo $?) -eq 0 ]]; then
  if command -v files-to-prompt >/dev/null 2>&1; then
    SUMMARY="$(files-to-prompt --markdown "${FILES[@]+"${FILES[@]}"}" \
      | llm -m "$MODEL" "You are creating a weekly review for $START to $END. 
Given the following notes, output:
1) Key themes (bullets)
2) Decisions (with context)
3) Risks/blocks
4) Next week focus
Keep it concise and structured in Markdown." )"
  else
    # Fallback: concatenate first 200 lines of each file to keep prompt modest
    TMPCTX="$(mktemp)"
    for f in "${FILES[@]+"${FILES[@]}"}"; do
      echo -e "\n\n# FILE: $f\n" >> "$TMPCTX"
      sed -n '1,200p' "$f" >> "$TMPCTX"
    done
    SUMMARY="$(cat "$TMPCTX" | llm -m "$MODEL" "Create a concise weekly review (themes, decisions, risks, next week) for $START to $END based on the material below.")"
    rm -f "$TMPCTX"
  fi
fi

# Write review
{
  echo "# Week $YEAR-$WEEKNUM ($START â†’ $END)"
  echo
  if [[ -n "$SUMMARY" ]]; then
    echo "## Summary"
    echo
    echo "$SUMMARY"
    echo
  fi
  echo "## Source notes"
  echo
  cat "$LINKS_TMP"
  echo
  if [[ -s "$DECISIONS_TMP" ]]; then
    echo "## Decisions (from notes)"
    echo
    cat "$DECISIONS_TMP"
  fi
  echo "## Open actions (unchecked)"
  echo
  if [[ -s "$ACTIONS_TMP" ]]; then cat "$ACTIONS_TMP"; else echo "_None detected._"; fi
  echo
} > "$OUT"

rm -f "$ACTIONS_TMP" "$DECISIONS_TMP" "$LINKS_TMP"

echo "Wrote $OUT"
[[ $NO_OPEN -eq 1 ]] || open_in_editor "$OUT"

