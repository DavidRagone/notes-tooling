#!/usr/bin/env bash
# shellcheck shell=bash
set -euo pipefail
HERE="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
. "$HERE/lib.sh"

ensure_dir "$TODO_DIR"
OUT="$TODO_DIR/TODO.md"
DONE_FILE="$TODO_DIR/done.md"

# Initialize the file with header if it doesn't exist
if [[ ! -f "$OUT" ]]; then
  {
    echo "# Open Tasks"
    echo
  } > "$OUT"
fi

# Function to extract task text from a todo line (handles both - [ ] and - [x] formats)
# Also handles the reference format like "Task  _(in [file](path#Lline))_"
extract_task_text() {
  local line="$1"
  # Remove checkbox and reference link, leaving just the task text
  printf '%s' "$line" | sed -E 's/^[[:space:]]*-[[:space:]]*\[[[:space:]x]\]//;s/[[:space:]]*_\(in \[.*\]\(.*\)\)_$//;s/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Pre-process done.md: extract all task texts into a temporary file for fast lookup
tmp_done_tasks="$(mktemp)"
if [[ -f "$DONE_FILE" ]]; then
  while IFS= read -r done_line; do
    # Skip empty lines and headers
    if [[ -z "$done_line" ]] || [[ "$done_line" =~ ^#+ ]] || [[ "$done_line" =~ ^### ]]; then
      continue
    fi
    # Extract task text from done.md line (handles - [x] format)
    done_task_text="$(extract_task_text "$done_line")"
    # Only add non-empty task texts
    if [[ -n "$done_task_text" ]]; then
      printf '%s\n' "$done_task_text"
    fi
  done < "$DONE_FILE" > "$tmp_done_tasks"
fi

# Collect new todos
tmp_new="$(mktemp)"
trap 'rm -f "$tmp_new" "$tmp_done_tasks"' EXIT

# Find unchecked boxes, print with file path for context.
# Exclude the todo file itself and common non-note dirs.
# Only match todos that have actual text after the brackets (exclude empty template todos like "- [ ] ")
rg --no-ignore-vcs --hidden --glob '!**/.git/**' --glob '!**/.index/**' \
   --glob '!**/.tooling/**' --glob '!**/todo/TODO.md' -n '^\s*-\s*\[ \]\s*\S' "$NOTES_DIR" 2>/dev/null \
| while IFS=: read -r file line text; do
    rel="$(relpath "$file" "$TODO_DIR")"
    base="$(basename "$file")"
    # strip leading checkbox+whitespace
    task="$(printf '%s' "$text" | sed -E 's/^[[:space:]]*-[[:space:]]*\[[[:space:]]\][[:space:]]*//;s/^[[:space:]]*//')"
    # Use a single formatted string to avoid %-expansion surprises on old Bash
    todo_line="$(printf -- '- [ ] %s  _(in [%s](%s#L%s))_' "${task}" "${base}" "${rel}" "${line}")"
    
    # Extract task text for comparison
    task_text="$(extract_task_text "$todo_line")"
    
    # Check if this exact todo line already exists in TODO.md
    already_in_todo=false
    if grep -qFx -- "$todo_line" "$OUT" 2>/dev/null; then
      already_in_todo=true
    fi
    
    # Check if task text exists in done.md using fast grep lookup
    already_in_done=false
    if [[ -s "$tmp_done_tasks" ]] && grep -qFx -- "$task_text" "$tmp_done_tasks" 2>/dev/null; then
      already_in_done=true
    fi
    
    # Only add if not in TODO.md and not in done.md
    if [[ "$already_in_todo" == false ]] && [[ "$already_in_done" == false ]]; then
      echo "$todo_line"
    fi
  done > "$tmp_new"

# Append new todos and count them
added_count=0
if [[ -s "$tmp_new" ]]; then
  while IFS= read -r todo_line; do
    echo "$todo_line" >> "$OUT"
    added_count=$((added_count + 1))
  done < "$tmp_new"
fi

if [[ $added_count -gt 0 ]]; then
  if [[ $added_count -eq 1 ]]; then
    echo "Added $added_count new todo to $OUT"
  else
    echo "Added $added_count new todos to $OUT"
  fi
else
  echo "No new todos found (file is up to date)"
fi
